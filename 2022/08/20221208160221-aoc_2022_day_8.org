:PROPERTIES:
:ID:       0f981707-91fc-49aa-bb15-28bbf415e0a6
:END:
#+title: AOC 2022 day 8
#+PROPERTY: header-args:python  :noweb no-export :results output :exports both
* Input
#+name: test-inp
#+begin_src text :eval no
30373
25512
65332
33549
35390
#+end_src

We want to parse the input as a matrix of integers.
#+name: parse
#+begin_src python :var inp=(get-val-of-named-src-block "test-inp") :results value
inp = [[int(n) for n in l] for l in inp.splitlines()]
return inp
#+end_src

#+RESULTS: parse
| 3 | 0 | 3 | 7 | 3 |
| 2 | 5 | 5 | 1 | 2 |
| 6 | 5 | 3 | 3 | 2 |
| 3 | 3 | 5 | 4 | 9 |
| 3 | 5 | 3 | 9 | 0 |

* Part 1
** With matrix rotations
Our algorithm looks like this:
- Let's say we have a separate matrix,
    where we mark if a tree is visible from any of the edges (left, bottom, right or top).
- When standing on an edge,
  we can look at each line of trees
  and mark the ones that we can see as =visible= in the separate matrix.
- We repeat this process from every edge.
- In the end, we count how many trees are =visible= from any of the sides.

First and foremost, we need to be able to look at a line of trees
and tell which ones are visible.

The following function takes in a list of integers,
representing the heights of trees in a singe line,
when viewed from left.
It returns a list of booleans,
each value representing whether the tree in that position is visible.
#+name: visible_in_line
#+begin_src python :results none
def visible_in_line(l):
    mx = -1
    v = [False] * len(l)
    for i, h in enumerate(l):
        if h > mx:
            mx = h
            v[i] = True
    return v
#+end_src

Let's test it on the first line of trees:
#+begin_src python :var inp=parse
<<visible_in_line>>
l = inp[0]
print(visible_in_line(l))
print(visible_in_line(l) == [True, False, False, True, False])
#+end_src

#+RESULTS:
: [True, False, False, True, False]
: True

We need to do this for each line of trees in the matrix:
#+name: visible_from_west
#+begin_src python :eval no
<<visible_in_line>>
def visible_from_west(m):
    return [visible_in_line(l) for l in m]
#+end_src

Let's check the result for our input.
#+begin_src python :var inp=parse() :results value
<<visible_from_west>>

return visible_from_west(inp)
#+end_src

#+RESULTS:
| True | False | False | True  | False |
| True | True  | False | False | False |
| True | False | False | False | False |
| True | False | True  | False | True  |
| True | True  | False | True  | False |

Remember, this tells us which trees are visible looking from the /left/ edge.
But we need to check from all four edges.
There's many ways to do that, but a conceptually simple one is to rotate the matrix.

This function rotates a matrix 90Â° counter-clockwise:
#+name: rotate
#+begin_src python :eval no
def rotate(m):
    return [[m[j][i] for j in range(len(m))] for i in range(len(m[0])-1,-1,-1)]
#+end_src

#+begin_src python :var m=parse() :results value
<<rotate>>
return rotate(m)
#+end_src

#+RESULTS:
| 3 | 2 | 2 | 9 | 0 |
| 7 | 1 | 3 | 4 | 9 |
| 3 | 5 | 3 | 5 | 3 |
| 0 | 5 | 5 | 3 | 5 |
| 3 | 2 | 6 | 3 | 3 |

We'll also need a method of applying a function multiple times.
#+name: repeat_apply
#+begin_src python :eval no
from itertools import repeat
from functools import reduce

def repeat_apply(func, n):
    if n == 0:
        return lambda x: x
    return lambda x: reduce(lambda x,f: f(x), repeat(func, n), x)
#+end_src

Here we'll test that all possible cases are correct (tedious but fulfilling):
#+begin_src python :results value :var inp=parse
<<repeat_apply>>
<<rotate>>
return repeat_apply(rotate, 0)(inp) == inp and \
        repeat_apply(rotate, 1)(inp) == rotate(inp) and \
        repeat_apply(rotate, 2)(inp) == rotate(rotate(inp)) and \
        repeat_apply(rotate, 3)(inp) == rotate(rotate(rotate(inp)))
#+end_src

#+RESULTS:
: True

Once we rotate the matrix to find the visible trees,
we need to then rotate it back to the original position.
Let's say, each side is denoted with an integer from 0 to 3,
starting with the west one and going clockwise (because we're rotating counter-clockwise).
Then, we can define this function:
#+name: visible_from_side
#+begin_src python :eval no
<<rotate>>
<<visible_from_west>>
<<repeat_apply>>

def visible_from_side(m, side):
    r = repeat_apply(rotate, side)(m)
    v = visible_from_west(r)
    return repeat_apply(rotate, (4-side)%4)(v)
#+end_src

Let's see what trees are visible, say, from the bottom edge:
#+begin_src python :var inp=parse :results value
<<visible_from_side>>

return visible_from_side(inp, 3)
#+end_src

#+RESULTS:
| False | False | False | False | False |
| False | False | False | False | False |
| True  | False | False | False | False |
| False | False | True  | False | True  |
| True  | True  | True  | True  | True  |

So how exactly do we combine the visibility arrays from two sides?
We need to =or= them, as a tree is visible from two sides
if it is visible from at least one of the sides.
#+name: matrix_or
#+begin_src python :eval no
def matrix_or(m1, m2):
    return [[a or b for a,b in zip(l1, l2)] for l1, l2 in zip(m1, m2)]
#+end_src

Quick test:
#+begin_src python
<<matrix_or>>
m1 = [[True, False], [True, False]]
m2 = [[True, True], [False, False]]

ored = matrix_or(m1, m2)
print(ored)
#+end_src

#+RESULTS:
: [[True, True], [True, False]]

Looks right.

Now, let's finally find out which trees are visible from any of the four sides.
#+name: visible
#+begin_src python :var inp=parse() :results value
<<visible_from_side>>
<<rotate>>
<<matrix_or>>

from functools import reduce

vl = [visible_from_side(inp, s) for s in range(4)]
v = reduce(matrix_or, vl)
return v
#+end_src

#+RESULTS: visible
| True | True  | True  | True  | True |
| True | True  | True  | False | True |
| True | True  | False | True  | True |
| True | False | True  | False | True |
| True | True  | True  | True  | True |

Last step is to count them:
#+begin_src python :var v=visible :results value
s = sum([sum(map(int, l)) for l in v])
return s
#+end_src

#+RESULTS:
: 21

=21= is the correct answer.

So, let's see if we can shorten all of this:
#+begin_src python :var inp=(get-val-of-named-src-block "test-inp") :results value
from itertools import repeat
from functools import reduce

inp = [[int(n) for n in l] for l in inp.splitlines()]

def visible_in_line(l):
    mx = -1
    v = [False] * len(l)
    for i, h in enumerate(l):
        if h > mx:
            mx = h
            v[i] = True
    return v

def visible_from_west(m):
    return [visible_in_line(l) for l in m]

def rotate(m):
    return [[m[j][i] for j in range(len(m))] for i in range(len(m[0])-1,-1,-1)]

def repeat_apply(func, n):
    if n == 0:
        return lambda x: x
    return lambda x: reduce(lambda x,f: f(x), repeat(func, n), x)

def visible_from_side(m, side):
    r = repeat_apply(rotate, side)(m)
    v = visible_from_west(r)
    return repeat_apply(rotate, (4-side)%4)(v)

def matrix_or(m1, m2):
    return [[a or b for a,b in zip(l1, l2)] for l1, l2 in zip(m1, m2)]

vl = [visible_from_side(inp, s) for s in range(4)]
v = reduce(matrix_or, vl)
s = sum([sum(map(int, l)) for l in v])
return s
#+end_src

#+RESULTS:
: 21

The =visible_in_line= can be shortened by noticing that the first tree in line is always visible,
no matter how high.
#+begin_src python :var inp=parse :results value
l = inp[0]

return [True] + [e > max(l[:i]) for i,e in enumerate(l[1:], 1)]
#+end_src

#+RESULTS:
| True | False | False | True | False |

I'll try to just compress it all:
#+begin_src python :var inp=(get-val-of-named-src-block "test-inp") :results value
from itertools import repeat
from functools import reduce

r = lambda f, n: lambda x: reduce(lambda x,f: f(x), repeat(f, n), x) if n != 0 else x
rot = lambda m: [[m[j][i] for j in range(len(m))] for i in range(len(m[0])-1,-1,-1)]
return sum([sum(map(int, l)) for l in reduce(lambda m1, m2: [[a or b for a,b in zip(l1, l2)] for l1, l2 in zip(m1, m2)], [r(rot, (4-s)%4)([[True] + [e > max(l[:i]) for i,e in enumerate(l[1:], 1)] for l in r(rot, s)([[int(n) for n in l] for l in inp.splitlines()])]) for s in range(4)])])
#+end_src

#+RESULTS:
: 21

Of course the result is just some crazy obfuscated code, but the process was pretty fun :D
** Using ranges
Instead of doing matrix rotations,
there is a more efficient (?) method:
simply iterating over all the elements while keeping them in place.

We'll need to look at each line from both directions.
The easiest case is looking at the horizontal lines from left to right:
#+begin_src python :var inp=parse
<<visible_in_line>>
l = (inp[0][i] for i in range(len(inp[0])))
print(l)
print(visible_in_line(l))
#+end_src

#+RESULTS:
: <generator object <genexpr> at 0x7fdc0ea40200>

To look from right to left, we can simply reverse it:
#+begin_src python :var inp=parse
<<visible_in_line>>
l = inp[0][::-1]
print(l)
print(visible_in_line(l))
#+end_src

#+RESULTS:
: [3, 7, 3, 0, 3]
: [True, True, False, False, False]

Better yet, we can use generators,
so we don't waste space.

But first, we'll need to modify this function
so that it works with generators:
#+name: visible_in_line2
#+begin_src python :results none
def visible_in_line(l):
    mx = -1
    v = []
    for i, h in enumerate(l):
        if h > mx:
            mx = h
            v.append(True)
        else:
            v.append(False)
    return v
#+end_src

Now we don't construct a list,
but a /generator/, which means it should both be faster and use less space.
#+begin_src python :var inp=parse
<<visible_in_line2>>
l = (inp[0][i] for i in range(len(inp[0])-1,-1,-1))
print(l)
print(visible_in_line(l))
#+end_src

#+RESULTS:
: <generator object <genexpr> at 0x7f2351241f50>
: [True, True, False, False, False]

But how do we make generators over the vertical lines?
Well, quite easy too:
#+begin_src python :var inp=parse
l = (inp[i][0] for i in range(len(inp)-1,-1,-1))
print(l)
print(list(l))
#+end_src

#+RESULTS:
: <generator object <genexpr> at 0x7fef53840200>
: [3, 3, 6, 2, 3]

So, let's take a look at all four cases:
#+begin_src python :var inp=parse
print((inp[0][i] for i in range(len(inp[0]))))
print((inp[0][i] for i in range(len(inp[0])-1,-1,-1)))
print((inp[i][0] for i in range(len(inp))))
print((inp[i][0] for i in range(len(inp)-1,-1,-1)))
#+end_src

#+RESULTS:
: <generator object <genexpr> at 0x7fd192640200>
: <generator object <genexpr> at 0x7fd192640200>
: <generator object <genexpr> at 0x7fd192640200>
: <generator object <genexpr> at 0x7fd192640200>

Instead of =0=, we want to iterate over all the rows in the first two cases,
and over all the columns in the last two.
But since the input is guaranteed to be a square,
we can conveniently combine the two cases and make a single function
that iterates over =n='th row and =n='th column at the same time:
#+begin_src python :results none :var inp=parse
for n in range(len(inp)):
    (inp[n][i] for i in range(len(inp[n])))
    (inp[n][i] for i in range(len(inp[n])-1,-1,-1))
    (inp[i][n] for i in range(len(inp)))
    (inp[i][n] for i in range(len(inp)-1,-1,-1))
#+end_src

Ok, but wait, what exactly were we going do with these rows?
First, we were going to check which trees are visible in each of them,
but then we need to somehow store that information in a single matrix.
So, after looking at the trees in, say, the first horizontal row from right to left,
we then need to reverse the result so that we can store it in the visibility matrix.

#+begin_src python :results value :var inp=parse
<<visible_in_line2>>
s = len(inp)
visible = [[False] * s for i in range(s)]

for n in range(s):
    l = (inp[n][i] for i in range(s))
    v = visible_in_line(l)
    for i in range(s):
        visible[n][i] |= v[i]

    l = (inp[n][i] for i in range(s-1,-1,-1))
    v = visible_in_line(l)
    for i in range(s):
        visible[n][i] |= v[s-i-1]

    l = (inp[i][n] for i in range(s))
    v = visible_in_line(l)
    for i in range(s):
        visible[i][n] |= v[i]

    l = (inp[i][n] for i in range(s-1,-1,-1))
    v = visible_in_line(l)
    for i in range(s):
        visible[i][n] |= v[s-i-1]

return visible
#+end_src

#+RESULTS:
| True | True  | True  | True  | True |
| True | True  | True  | False | True |
| True | True  | False | True  | True |
| True | False | True  | False | True |
| True | True  | True  | True  | True |

We got the right answer, but the code looks too repetitive.

We can make it a bit shorter:
#+begin_src python :results value :var inp=parse
<<visible_in_line2>>
s = len(inp)
visible = [[False] * s for i in range(s)]

for n in range(s):
    for i in range(s):
        visible[n][i] |= visible_in_line((inp[n][i] for i in range(s)))[i]
        visible[n][i] |= visible_in_line((inp[n][i] for i in range(s-1,-1,-1)))[s-i-1]
        visible[i][n] |= visible_in_line((inp[i][n] for i in range(s)))[i]
        visible[i][n] |= visible_in_line((inp[i][n] for i in range(s-1,-1,-1)))[s-i-1]

return visible
#+end_src

#+RESULTS:
| True | True  | True  | True  | True |
| True | True  | True  | False | True |
| True | True  | False | True  | True |
| True | False | True  | False | True |
| True | True  | True  | True  | True |

The entire solution then becomes:
#+begin_src python :results value :var inp=(get-val-of-named-src-block "test-inp") :noweb yes
<<visible_in_line2>>

inp = [[int(n) for n in l] for l in inp.splitlines()]
s = len(inp)
v = [[False] * s for i in range(s)]
for n in range(s):
    for i in range(s):
        v[n][i] |= visible_in_line((inp[n][i] for i in range(s)))[i]
        v[n][i] |= visible_in_line((inp[n][i] for i in range(s-1,-1,-1)))[s-i-1]
        v[i][n] |= visible_in_line((inp[i][n] for i in range(s)))[i]
        v[i][n] |= visible_in_line((inp[i][n] for i in range(s-1,-1,-1)))[s-i-1]

return sum([sum(map(int, l)) for l in v])
#+end_src

#+RESULTS:
: 21
